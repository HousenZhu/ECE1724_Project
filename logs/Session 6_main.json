{
  "id": 0,
  "name": "main",
  "messages": [
    {
      "from": "User",
      "content": "/help"
    },
    {
      "from": "Assistant",
      "content": "Available tools:\n- filesystem.read  - read file content. Example: <use_tool name=\"filesystem.read\" params={\"path\": \"src/main.rs\"} />\n- filesystem.write - write text into a file. Example: <use_tool name=\"filesystem.write\" params={\"path\": \"output.txt\", \"content\": \"Hello\"} />\n- shell.run - run shell commands. Example: <use_tool name=\"shell.run\" params={\"content\": \"mkdir Playground\"} />\n\nThese tools can be used to interact with the file system and execute shell commands. Let me know how I can assist you! \n\nDone.\n[Tool: filesystem.read]\nresult: Read file 'src/main.rs' (3793 bytes). Content:\nmod app;\nmod tui;\nmod frontend;\n\nuse std::{\n    io::{stdout, Stdout},\n    time::Duration,\n    sync::mpsc,\n    env, \n    process::Command\n};\n\nuse anyhow::Result;\nuse crossterm::{\n    event::{self, Event, EnableMouseCapture, DisableMouseCapture},\n    execute,\n    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen},\n};\nuse frontend::keyboard::handle_key_event;\nuse frontend::mouse::handle_mouse_event;\nuse ratatui::{backend::CrosstermBackend, Terminal};\n\nuse crate::app::{App, BackendEvent};\nuse crate::tui::ui as draw_ui;\n\n/// Initialize terminal in raw mode and enter an alternate screen.\nfn setup_terminal() -> Result<Terminal<CrosstermBackend<Stdout>>> {\n    enable_raw_mode()?;\n    let mut out = stdout();\n    execute!(out, EnterAlternateScreen, EnableMouseCapture)?;\n    let backend = CrosstermBackend::new(out);\n    let terminal = Terminal::new(backend)?;\n    Ok(terminal)\n}\n\n/// Restore terminal back to normal mode.\nfn restore_terminal(mut terminal: Terminal<CrosstermBackend<Stdout>>) -> Result<()> {\n    disable_raw_mode()?;\n    execute!(terminal.backend_mut(), LeaveAlternateScreen, DisableMouseCapture)?;\n    terminal.show_cursor()?;\n    Ok(())\n}\n\nfn main() -> Result<()> {\n    // Pop out into a separate macOS Terminal window once.\n    #[cfg(target_os = \"macos\")]\n    {\n        if env::var(\"MYCLI_POPPED\").is_err() {\n            pop_out_terminal()?;\n            std::process::exit(0);\n        }\n    }\n\n    run_tui()\n}\n\nfn run_tui() -> Result<()> {\n    let mut terminal = setup_terminal()?;\n\n    let mut app = App::new();\n    \n    // Create a channel for backend events (assistant streaming).\n    let (tx, rx) = mpsc::channel::<BackendEvent>();\n    app.backend_tx = Some(tx);\n\n    loop {\n        // 0) Drain backend events before drawing\n        while let Ok(event) = rx.try_recv() {\n            match event {\n                BackendEvent::AssistantChunk { session_idx, branch_idx, chunk } => {\n                    app.append_assistant_chunk(session_idx, branch_idx, chunk);\n                }\n                BackendEvent::AssistantDone { session_idx, branch_idx, } => {\n                    app.save_to_logs().ok();\n                    app.finish_streaming(session_idx, branch_idx);\n                }\n\n            }\n        }\n\n        // 1) Draw the UI based on current state.\n        terminal.draw(|f| draw_ui(f, &mut app))?;\n\n        // 2) Handle input events (non-blocking poll).\n        if event::poll(Duration::from_millis(50))? {\n            match event::read()? {\n                Event::Key(key) => {\n                    // Delegate key handling to keyboard::handle_key_event.\n                    // If it returns true, we should exit the loop.\n                    if handle_key_event(key.code, &mut app)? {\n                        break;\n                    }\n                }\n                Event::Mouse(m) => {\n                    handle_mouse_event(m, &mut app)?;\n                }\n                _ => {\n                    // Ignore other events (e.g. Resize) for now.\n                }\n            }\n        }\n    }\n    // After breaking out of the loop, restore the terminal and exit cleanly.\n    restore_terminal(terminal)?;\n    Ok(())\n}\n\n#[cfg(target_os = \"macos\")]\nfn pop_out_terminal() -> Result<()> {\n    // Find the current executable path.\n    let exe = env::current_exe()?;\n    let cwd = env::current_dir()?;\n\n    // Small AppleScript snippet:\n    // - activate Terminal\n    // - open a new window running this binary\n    let script = format!(\n        r#\"tell application \"Terminal\"\n    activate\n    do script \"cd '{}'; export MYCLI_POPPED=1; '{}'\"\nend tell\"#,\n        cwd.display(),\n        exe.display()\n    );\n\n    Command::new(\"osascript\")\n        .arg(\"-e\")\n        .arg(&script)\n        .spawn()?; \n\n    Ok(())\n}\n"
    }
  ]
}